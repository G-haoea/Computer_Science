# 目录   
* [传输层简介](#传输层简介)     
* [TCP和UDP的特点](#TCP和UDP的特点)     
  * [TCP](#TCP)     
  * [UDP](#UDP)     
* [TCP和UDP的首部格式](#TCP和UDP的首部格式)     
  * [TCP](#TCP)     
  * [UDP](#UDP)     
* [TCP三次握手](#TCP三次握手)     
* [TCP四次挥手](#TCP四次挥手)     
* [TCP可靠传输](#TCP可靠传输)     
  * [超时重传](#超时重传)     
  * [以字节为单位的滑动窗口](#以字节为单位的滑动窗口)     
* [TCP流量控制](#TCP流量控制)     
* [TCP拥塞控制](#TCP拥塞控制)     
  * [慢开始](#慢开始)     
  * [拥塞避免](#拥塞避免)     
  * [快重传](#快重传)     
  * [快恢复](#快恢复)     
  * [Tips](#Tips)     
  
  
# 传输层简介
* 网络层只是把分组发送到目的主机，但是真正通信的并不是主机，而是主机中的进程；
* 网络层为主机之间提供逻辑通信，而传输层为应用进程之间提供端到端的逻辑通信；
---
* 传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道；
* 从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信的最高层，用户功能中的最底层；

# TCP和UDP的特点
## TCP
传输控制协议，Transmission Control Protocol
* 面向连接；
* 提高可靠交付；
* 有流量控制，拥塞控制；
* 提供全双工通信；
* 面向字节流：把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块；
（不保证数据块一一对应，但字节流必须一致，不封装）
* 每一条TCP连接只能是点对点的，即一对一；
![image5-1](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-1.JPG)
（以上是一条虚连接，即逻辑连接，并不是一条真正的物理连接。TCP报文段先传送到IP层，加上IP首部后，再传送到数据链路层，再加上数据链路层的首部和尾部之后，才离开主机发送到物理链路）

## UDP
用户数据报协议，User Datagram Protocol
* 无连接的，因此不需要套接字（TCP之间的通信必须要在两个套接字之间建立连接）；
* 尽最大可能交付；
* 没有拥塞控制：因此网络出现的拥塞不会使源主机的发送速率降低，那么就适用于实时应用，比如实时视频会议或者IP电话等，要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延；
* 面向报文：对于应用程序传下来的报文，不合并也不拆分，还要保留边界，只是添加UDP首部，会降低IP层效率；
* 支持一对一，一对多，多对一，多对多的交互通信；
* 首部只有8个字节开销小（TCP有20个）；
* 

# TCP和UDP的首部格式
## TCP
![image5-2](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-2.JPG)

* 源端口和目的端口：各占两个字节，16位，分别写入源端口号和目的端口号，当传输层收到IP层交上来的传输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用进程；
（端口号只具有本地意义，只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口）
* 序号：对字节流进行编号，4个字节，32位。（例如序号为301表示第一个字节流的编号为301，如果携带的数据长度是100字节，那么下一个报文段的序号应该是401）
* 确认号：期望收到的下一个报文段的序号。（例如B正确收到A发来的一个报文段，序号为501，携带的数据长度为200字节，那么B期望下一个报文段的序号为701，B发给A的确认报文段中确认号就为701）
* 数据偏移：4位，指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度；
* 保留：占6位，目前应为0；
---
【以下6个控制位各占1位】
* URG：紧急，1有效；
* `ACK`：确认，1有效，TCP规定，在连接建立之后，所有传送的报文段都必须把ACK置为1；
* PSH：推送，1有效，发送方把PSH置为1之后，立即创建一个报文段发送出去，接收方收到之后尽快的推送交付接收应用进程，不用等到整个缓存都填满了再向上交付；
* RST：复位，1表明连接中出现严重差错，必须释放连接，重新建立传输连接；
* `SYN`：同步，SYN=1 ACK=0表明这是一个连接请求报文段，如果对方同意建立连接，在相应的报文段中SYN=1 ACK=1；
* `FIN`：终止，1表明这个报文段的发送方的数据已经发送完毕，请求释放运输连接；
---
* 窗口：占2个字节，16位，作为接收方让发送方设置其发送窗口的依据，因为接收方的数据缓存空间是有效的；
* 检验和：占2个字节，16位，检验范围包括首部和数据部分，不同于IP数据报的检验和只检验首部。在计算检验和时，在TCP报文段前面加上12字节的伪首部；
* 紧急指针：占2个字节，16位，只有在URG=1时才有意义，指出了本报文段中的紧急数据的字节数，即紧急数据的末尾在报文段中的位置；（窗口为0也可以发送紧急数据）
---
【以下是非必有的】
* 选项：长度可变，最长40字节，没有选项时，TCP首部长度20字节；

## UDP
![image5-3](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-3.png)
首部字段只有8个字节，包括源端口，目的端口，长度，检验和。12字节的伪首部是为了计算检验和临时添加的。

# TCP三次握手
![image5-4](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-4.JPG)

* 防止失效的连接请求到达服务器，让服务器错误打开连接；
* 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认；
* 客户端等待一个超时重传时间之后，就会重新连接请求连接；
* 但是这个滞留的连接请求最后还是会到达服务器；
---
* 如果不进行三次握手，那么服务器就会打开两个连接；
* 如果有三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接；

# TCP四次挥手
![image5-5](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-5.JPG)

* 客服端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入了**CLOSE-WAIT**状态，这个状态是为了让服务器端发送还未传送完毕的数据；
* 传送完毕之后，服务器会发送FIN连接释放报文；
* 客户端接收到服务器端的FIN报文之后进入**TIME-WAIT**状态，此时并不是直接进入CLOSED状态，还需要等待一个时间计时器设置的时间2MSL（最长报文段寿命MSL，建议2min），理由是：
    * 确保最后一个确认报文能够到达：如果B没有收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况发生；
    * 让本连接持续时间内所产生的报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文；

# TCP可靠传输
## 超时重传
* 如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段；
* 一个报文段从发送再到接收到确认所经过的时间称为往返时间RTT；

## 以字节为单位的滑动窗口
![image5-6](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-6.png)
* 窗口是缓存的一部分，用来暂时存放字节流；
* 接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小；
---
* 发送窗口内的所有字节都允许被发送，接收窗口内的所有字节都允许被接收；
* 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，知道左部第一个字节不是已发送并且已确认的状态；
* 接收窗口的滑动类似，接收窗口左部字节已经发送确认交付给主机，就向右滑动接受窗口；
---
* 接收窗口只会对窗口内最后一个按序到达的字节进行确认。
* 例如：接收窗口已经收到的字节为{31，34，35}，其中31按序到达，34和35不是，因此只对字节31进行确认；
* 发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收；

# TCP流量控制
* 为了控制发送方发送速率，保证接收方来得及接收；
* 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率；
* 将窗口字段设为0则发送方不能发送数据；

# TCP拥塞控制
* 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高；
* 出现拥塞时，应当控制发送方速率，但和流量控制的目的不同；
* 流量控制是为了让接收方来得及接收，拥塞控制是为了降低整个网络的拥塞程度；
![image5-7](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-7.png)
* 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意实际决定发送方能发送多少数据的是发送方窗口，而不是拥塞窗口。
`发送方窗口上限值 = Min(接收方窗口rwnd， 拥塞窗口cwnd)`
（虽然TCP的窗口基于字节，但是图中的cwnd意为几个报文段，窗口大小单位为报文段）
![image5-8](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-8.png)

## 慢开始
* 设置一个慢开始门限ssthresh，当cwnd >= ssthresh时，进入拥塞避免；
* 1 -> 2 -> 4 -> 8 -> 16 -> 拥塞避免；

## 拥塞避免
* 如果出现超时，则改变慢开始门限ssthresh，重新进入慢开始；
* 16 -> 17 -> 18 -> 19 -> 20 -> 21 -> 22 -> 23 -> 24(超时) -> ssthresh = cwnd / 2 -> 慢开始（cwnd = 1 -> 2 -> 4...）；

## 快重传
* 接收方每次接收到报文段都应该对最后一个已收到的有序报文段进行确认；
* 发送方如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段；
![image5-9](https://github.com/iii17-grace/Computer_Science/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/image5-9.png)


## 快恢复
* 在cwnd变化情况的图中点4⃣️，发送方知道只是丢失了个别的报文段，于是不执行慢开始，而是执行快恢复；
* ssthresh = cwnd / 2 = 8；
* cwnd = ssthresh = 8；
* 开始执行拥塞避免算法；

## Tips
* 慢开始和快恢复的快慢指的是cwnd的设定值，而不是cwnd的增长速率；
* 慢开始cwnd设为1，快恢复cwnd设为ssthresh；
