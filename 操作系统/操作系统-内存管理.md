# 操作系统-内存管理
* [虚拟内存](#虚拟内存)      
* [分页系统地址映射](#分页系统地址映射)      
* [页面置换算法](#页面置换算法)      
  * [最佳 OPT](#最佳-OPT)      
  * [最近最久未使用 LRU](#最近最久未使用-LRU)      
  * [最近未使用 NRU](#最近未使用-NRU)      
  * [先进先出 FIFO](#先进先出-FIFO)      
  * [第二次机会算法](#第二次机会算法)      
  * [时钟 Clock](#时钟-Clock)      
* [分段](#分段)      
* [段页式](#段页式)      
* [分页与分段对比](#分页与分段对比)      

# 虚拟内存
* 让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存；
* 将内存抽象为地址空间；
* 每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页；
* 这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中；
* 当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令；
---
【虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，即一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能】

# 分页系统地址映射
* 内存管理单元（MMU）管理着地址空间和物理内存的转换；
* 其中的页表page table存储着页（程序地址空间）和页框（物理内存空间）的映射表；
* 一个虚拟地址分成两个部分：一部分存储页面号，一部分存储偏移量；

# 页面置换算法
* 程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断，从而将该页调入内存中；
* 此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间；
* 和缓存淘汰策略类似，可以将内存看成磁盘的缓存；
* 在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据；
* 主要目标是使页面置换频率最低（缺页率最低）；

## 最佳 OPT
optimal replacement algorithm
* 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率；
* 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问；

## 最近最久未使用 LRU
least recently used
* 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况，将最近最久未使用的页面换出；
* 为了实现LRU，需要在内存中维护一个所有页面的链表；
* 当一个页面被访问时，将这个页面移到链表表头，这样就能保证链表表尾的页面是最近最久未访问的；
* 因为每次访问都需要更新链表，因此这种方式实现的LRU代价很高；
![image4-1](media/15936659604306/image4-1.png)

## 最近未使用 NRU
not recently used
* 每个页面都有两个状态位：R 与 M；
* 当页面被访问时，设置页面的R=1，当页面被修改时，设置页面的M=1；
* 其中R会定时被清零，可以将页面分成以下四类：
    * R = 0, M = 0;
    * R = 0, M = 1;
    * R = 1, M = 0;
    * R = 1, M = 1;
* 当发生缺页中断时，NRU算法随机地从类编号最小的非空类中挑选一个页面将它换出；
* NRU优先换出已经被修改的脏页面（R=0,M=1），而不是被频繁使用的干净页面（R=1,M=0）；

## 先进先出 FIFO
first in first out
* 选择换出的页面是最先进入的页面；
* 会将哪些经常被访问的页面换出，导致缺页率升高；

## 第二次机会算法
* FIFO可能会把经常使用的页面置换出去，为了避免这一问题，有了第二次机会算法；
* 当页面被访问（读/写）时，该页面的R=1；
* 需要替换的时候，检查最老页面的R位；
* 如果是0，那么这个页面就是又老又没有被使用，可以立刻置换掉；
* 如果是1，就将R=0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索；

## 时钟 Clock
* 第二次机会算法需要在链表中移动页面，降低效率；
* 时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面；

# 分段
* 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射；
* 分段是把每个表分成段，一个段构成一个独立的地址空间，每个段段长度可以不同，并且可以动态增长；

# 段页式
* 程序的地址空间划分成多个拥有独立地址空间的段；
* 每个段上的地址空间划分成大小相同的页；
* 既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能；

# 分页与分段对比
|          | 分页                 | 分段                                |
|----------|--------------------|-----------------------------------|
| 对程序员的透明性 | 透明                 | 需要程序员显式划分每个段                      |
| 地址空间的维度  | 一维地址空间             | 二维地址空间                            |
| 大小是否可以改变 | 不可变                | 可动态改变                             |
| 出现的原因    | 实现虚拟内存，从而获得更大的地址空间 | 使程序和数据可以被划分为逻辑上独立的地址空间，并且有助于共享和保护 |
|          |                    |                                   |


