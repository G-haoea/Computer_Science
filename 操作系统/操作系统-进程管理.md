# 操作系统-进程管理      
* [进程与线程](#进程与线程)    
  * [进程](#进程)    
  * [线程](#线程)    
  * [区别](#区别)    
    * [拥有资源](#拥有资源)    
    * [调度](#调度)    
    * [系统开销](#系统开销)    
    * [通信方面](#通信方面)    
* [进程状态的切换](#进程状态的切换)    
* [进程调度算法](#进程调度算法)    
  * [批处理系统](#批处理系统)    
    * [先来先服务 FCFS](#先来先服务-FCFS)    
    * [短作业优先 SJF](#短作业优先-SJF)    
    * [最短剩余时间优先 SRTN](#最短剩余时间优先-SRTN)    
  * [交互式系统](#交互式系统)    
    * [时间片轮转](#时间片轮转)    
    * [优先级调度](#优先级调度)    
    * [多级反馈队列](#多级反馈队列)    
  * [实时系统](#实时系统)    


# 进程与线程
## 进程
* 进程是资源分配的基本单位；
* 进程控制块PCB：process control block，描述进程的基本信息和运行状态；
* 所谓的创建进程和撤销进程，都是指对PCB的操作；
![image2-1](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image2-1.png)


## 线程
* 线程是独立调度的基本单位；
* 一个进程中可以有多个线程，它们共享进程资源；
* 浏览器和微信是两个进程，浏览器进程里面有很多线程，例如http请求线程、事件响应线程、渲染线程等；
* 线程的并发执行使得在浏览器中点击一个新链接从而发起http请求时，浏览器还可以响应用户的其它事件；

## 区别
### 拥有资源
* 进程是资源分配的基本单位；
* 但是线程不拥有资源，线程可以访问隶属进程的资源；

### 调度
* 线程是独立调度的基本单位；
* 在同一个进程中，线程的切换不会引起进程切换；
* 从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换；

### 系统开销
* 由于**创建或撤销**进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销；
* 在进行进程**切换**时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置。而线程切换时只需要保存和设置少量寄存器内容，开销很小；

### 通信方面
* 线程间可以通过直接读写同一进程中的数据进行通信；
* 但是进程通信需要借助IPC；

# 进程状态的切换
![image2-2](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image2-2.JPG)
![image2-3](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image2-3.png)

* 就绪状态（ready）：进程做好了准备，只要有机会就开始调度，等待被调度；
* 运行状态（running）：该进程正在执行；
* 阻塞/等待状态（waiting）：进程在某些事件发生前不能执行，如I/O操作完成，等待资源；
* 新建状态（created）：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中，通常是进程控制块PCB已经创建但还没有加载到内存中的新进程；
* 退出状态（terminated）：操作系统从可执行进程中释放出来的进程，或者是因为它自身停止了，或者是因为某种原因被取消；
---
【Tips】
* 只有就绪态和运行态可以相互转换，其它的都是单向转换；
* 就绪态的进程通过调度算法从而获得CPU事件，转为运行态；
* 运行态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度；
* 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态；

# 进程调度算法
不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。
## 批处理系统
`FCFS SJF SRTN`
批处理系统没有太多的用户操作，在该系统中，调度算法目标是**保证吞吐量和周转时间**（从提交到终止的时间）。

### 先来先服务 FCFS
first come first served
* 非抢占式的调度算法，按照请求的顺序进行调度；
* 有利于长作业，但不利于短作业；
* 因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长；

### 短作业优先 SJF
shortest job first
* 非抢占式的调度算法，按估计运行时间最短的顺序进行调度；
* 长作业有可能会饿死，处于一直等待短作业执行完毕的状态；
* 因为如果一直有短作业的到来，那么长作业永远都得不到调度；

### 最短剩余时间优先 SRTN
shortest remaining time next
* 最短作业优先的抢占式版本，按照剩余运行时间的顺序进行调度；
* 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较，如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待；

## 交互式系统
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

### 时间片轮转
* 将所有的就绪进程按照FCFS的原则排成一个队列；
* 每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片；
* 当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行；
* 并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程；
---
【时间片轮转算法的效率和时间片的大小有关系】
* 进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换的太频繁，在进程切换上就会花过多时间；
* 而如果时间片过长，那么实时性就不能得到保证；
![image2-4](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image2-4.png)

### 优先级调度
* 为每个进程分配一个优先级，按优先级进行调度；
* 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级；

### 多级反馈队列
* 一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次；
* 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如：1，2，4，8……；
* 进程在第一个队列没执行完，就会被移到下一个队列，这种方式下，之前的进程只需要交换7次；
* 每个队列优先权也不同，最上面的优先权最高，因此只有上一个队列没有进程在排队，才能调度当前队列上的进程；
![image2-5](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image2-5.png)

## 实时系统
实时系统要求一个请求在一个确定时间内得到响应；
* 硬实时：必须满足绝对的截止时间；
* 软实时：可以容忍一定的超时；
