# 操作系统-死锁
* [简述](#简述)     
* [必要条件](#必要条件)     
* [处理方法](#处理方法)     
  * [鸵鸟策略](#鸵鸟策略)     
  * [死锁检测与死锁恢复](#死锁检测与死锁恢复)     
    * [每种类型一个资源的死锁检测](#每种类型一个资源的死锁检测)     
    * [每种类型多个资源的死锁检测](#每种类型多个资源的死锁检测)     
    * [死锁恢复](#死锁恢复)     
  * [死锁预防](#死锁预防)     
    * [破坏互斥条件](#破坏互斥条件)     
    * [破坏占有和等待条件](#破坏占有和等待条件)     
    * [破坏不可抢占条件](#破坏不可抢占条件)     
    * [破坏环路等待](#破坏环路等待)     
  * [死锁避免](#死锁避免)     
    * [安全状态](#安全状态)     
    * [单个资源的银行家算法](#单个资源的银行家算法)     
    * [多个资源的银行家算法](#多个资源的银行家算法)     



# 简述
* 一组相互竞争系统资源或进行通信的进程间的“永久”阻塞；
* 这组进程发生阻塞：当一组进程中的每个进程都在等待某个事件（典型的情况是等待所请求的资源被释放），而只有在这组中的其他被阻塞的进程才可以触发该事件；
* 因为没有事件能够被触发，所以死锁是永久性的；

# 必要条件
* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的；
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源；
* 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放；
* 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源；
![image3-1](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-1.png)

# 处理方法
## 鸵鸟策略
* 把头埋进沙子里，假装根本没发生问题；
* 因为解决死锁代价很高，鸵鸟策略这种不采取任务措施的方案会获得更高的性能；
* 当发生死锁时不会对用户造成多大影响，或者发生死锁的概率很低，可以用鸵鸟策略；
* 大多数操作系统linux/windows等处理死锁都是忽略它；

## 死锁检测与死锁恢复
不试图阻止它，而是当检测到死锁发生时，采取措施进行恢复；
### 每种类型一个资源的死锁检测
* 通过检测有向图是否存在环来实现；
* 从一个节点出发进行深度优先搜索，对访问过的节点进行标记；
* 如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生；
![image3-2](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-2.png)

### 每种类型多个资源的死锁检测
* 每个进程最开始时都不被标记，执行过程有可能被标记；
* 当算法结束时，任何没有被标记的进程都是死锁进程；
* 寻找一个没有标记的进程Pi，它所请求的资源小于等于A;
* 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转回1；
* 如果没有这样一个进程，算法终止；
![image3-3](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-3.png)
![image3-4](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-4.JPG)

### 死锁恢复
* 抢占恢复；
* 回滚恢复；
* 杀死进程恢复；

## 死锁预防
在程序运行之前预防发生死锁。
### 破坏互斥条件
例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

### 破坏占有和等待条件
可以规定所有进程在开始执行前请求所需要的全部资源。

### 破坏不可抢占条件

### 破坏环路等待
给资源统一编号，进程只能按编号顺序来请求资源。

## 死锁避免
在程序运行时避免发生死锁。
### 安全状态
* 如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的；
* 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁；
![image3-5](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-5.png)
【从图a出发，运行顺序B -> C -> A，全能成功运行，所以图a所示状态是安全的】

### 单个资源的银行家算法
* 一个银行家向一群客户分别承诺了一定的贷款额度；
* 算法要做的是判断对请求的满足是否会进入不安全状态；
* 如果是，就拒绝请求；
* 否则，予以分配
![image3-6](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-6.png)
【图c不安全（free的1不管加到哪都不能让has=max），因此算法会拒绝之前的请求，从而避免进入图c中的状态】

### 多个资源的银行家算法
* 查找右边的矩阵是否存在一行小于等于向量A，如果不存在这样的行，那么系统将会发生死锁，状态是不安全的；
* 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到A中；
* 重复以上两步，直到所有进程都标记为终止，则状态是安全的；
* 如果一个状态不是安全的，需要拒绝进入这个状态；
![image3-7](https://github.com/iii17-grace/Computer_Science/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image3-7.JPG)




