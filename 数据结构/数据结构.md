# 目录    
* [线性结构](#线性结构)    
  * [递归](#递归)    
  * [数组](#数组)     
  * [栈](#栈)    
  * [队列](#队列)    
  * [单链表](#单链表)    
  * [双链表](#双链表)     
  * [循环链表](#循环链表)    
  * [双向循环链表](#双向循环链表)    

# 线性结构
## 递归
### 斐波那契数列Febonacci
* 根本思想：找到基本的**跳出条件**是数列前两位是1、1，数列后面的都是前一位和前两位的和;

```java
public class Febonacci {
	public static int febonacci(int num) {
		if(num == 1 || num == 2) {
			return 1;
		}
		return febonacci(num-1) + febonacci(num-2);
	}
	
	public static void main(String args[]) {
		System.out.println(febonacci(7));
	}
}
```   

### 汉诺塔问题Hanoi
* 根本思想：把所有的碟子只分为上下两部分；
* Step 1：把除了最下面的一个碟子之外的上面所有碟子作为一个整体移动到缓冲柱子上；
* Step 2：把最下面的一个碟子移动到目标柱子上；
* Step 3：把缓冲柱子上的所有柱子移动到目标柱子上；

```java
public class Hanoi {
	public static void hanoi(int num, char from, char buffer, char to) {
		if(num == 1) {
			System.out.println("第" + 1 + "个盘子从" + from + "移动到" + to);
			return;
		}
		hanoi(num-1, from, to, buffer);
		System.out.println("第" + num + "个盘子从" + from + "移动到" + to);
		hanoi(num-1, buffer, from, to);
		
	}
	
	public static void main(String args[]) {
		hanoi(3, 'A', 'B', 'C');
	}
}
```

## 数组
### 建立数组及添加元素
```java
public class MyArray {
	public int[] arr;
	
	public MyArray() {
		arr = new int[0];
	}
	
	public void add(int value) {
		int[] newArr = new int[arr.length+1];
		for(int i=0; i<arr.length; i++) {
			newArr[i] = arr[i];
		}
		newArr[arr.length] = value;
		arr = newArr;
	}
	
```

### 输出数组展示
```java
    public void show() {
		System.out.println("arr: " + Arrays.toString(arr));
	}
```    
	
### 替换第index位为value
```java   
	public void replace(int value, int index) {
		arr[index] = value;
	}
```

### 在index位后插入value
```java
	public void insert(int value, int index) {
		int[] newArr = new int[arr.length+1];
		for(int i=arr.length; i>index+1; i--) {
			newArr[i] = arr[i-1];
		}
		for(int i=0; i<index+1; i++) {
			newArr[i] = arr[i];
		}
		newArr[index+1] = value;
		arr = newArr;
	}
```

### 删除第index位元素
```java
	public void delete(int index) {
		int[] newArr = new int[arr.length-1];
		for(int i=0; i<index; i++) {
			newArr[i] = arr[i];
		}
		for(int i=index; i<newArr.length; i++) {
			newArr[i] = arr[i+1];
		}
		arr = newArr;
	}
```

### 查找值为value的所有的index
```java
	public void search(int value) {
		int[] indexArr = new int[arr.length];
		int count = 0;
		for(int i=0; i<arr.length; i++) {
			if(arr[i] == value) {
				indexArr[count++] = i;
			}
		}
		if(count == 0) {
			System.out.println("It does not found.");
		}else {
			for(int i=0; i<count; i++) {
				System.out.print(indexArr[i] + " ");
			}
		}
	}
```
	
### 二分法查找值为value的元素index，前提是数组是有序的
```java
	public void binarySearch(int value) {
		
		int start = 0;
		int end = arr.length-1;
		int mid = (start + end) / 2;
		while(true) {
			if(arr[mid] == value) {
				System.out.println(mid);
				break;
			}else {
				if(arr[mid] > value) {
					end = mid-1;
				}else {
					start = mid+1;
				}
				mid = (start + end) / 2;
			}
		}
	}
}
```

### 测试用例
```java 
public class TestMyArray {
	public static void main(String args[]) {
		MyArray arr = new MyArray();
		
		arr.add(1);
		arr.add(2);
		arr.show();
		//arr: [1, 2]

		
		arr.replace(1, 1);
		arr.show();
                //arr: [1, 1]

		
		arr.insert(3, 0);
		arr.show();
		//arr: [1, 3, 1]

		
		arr.delete(1);
		arr.show();
		//arr: [1, 1]

		
		arr.search(2);
		//It does not found.

		
		MyArray orderArr = new MyArray();
		
		orderArr.add(1);
		orderArr.add(2);
		orderArr.add(3);
		
		orderArr.binarySearch(2);
		//1
		
		
	}
}

```


## 栈

## 队列

## 单链表

## 双链表

## 循环链表

## 双向循环链表

