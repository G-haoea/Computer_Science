# 目录    
* [线性结构](#线性结构)    
  * [递归](#递归)    
  * [数组](#数组)     
  * [栈](#栈)    
  * [队列](#队列)    
  * [单链表](#单链表)    
  * [双链表](#双链表)     
  * [循环链表](#循环链表)    
  * [双向循环链表](#双向循环链表)    

# 线性结构
## 递归
### 斐波那契数列Febonacci
* 根本思想：找到基本的**跳出条件**是数列前两位是1、1，数列后面的都是前一位和前两位的和;

```java
public class Febonacci {
	public static int febonacci(int num) {
		if(num == 1 || num == 2) {
			return 1;
		}
		return febonacci(num-1) + febonacci(num-2);
	}
	
	public static void main(String args[]) {
		System.out.println(febonacci(7));
	}
}
```   

### 汉诺塔问题Hanoi
* 根本思想：把所有的碟子只分为上下两部分；
* Step 1：把除了最下面的一个碟子之外的上面所有碟子作为一个整体移动到缓冲柱子上；
* Step 2：把最下面的一个碟子移动到目标柱子上；
* Step 3：把缓冲柱子上的所有柱子移动到目标柱子上；

```java
public class Hanoi {
	public static void hanoi(int num, char from, char buffer, char to) {
		if(num == 1) {
			System.out.println("第" + 1 + "个盘子从" + from + "移动到" + to);
			return;
		}
		hanoi(num-1, from, to, buffer);
		System.out.println("第" + num + "个盘子从" + from + "移动到" + to);
		hanoi(num-1, buffer, from, to);
		
	}
	
	public static void main(String args[]) {
		hanoi(3, 'A', 'B', 'C');
	}
}
```

## 数组
### 建立数组及添加元素
```java
public class MyArray {
	public int[] arr;
	
	public MyArray() {
		arr = new int[0];
	}
	
	public void add(int value) {
		int[] newArr = new int[arr.length+1];
		for(int i=0; i<arr.length; i++) {
			newArr[i] = arr[i];
		}
		newArr[arr.length] = value;
		arr = newArr;
	}
	
```

### 输出数组展示
```java
    public void show() {
		System.out.println("arr: " + Arrays.toString(arr));
	}
```    
	
### 替换第index位为value
```java   
	public void replace(int value, int index) {
		arr[index] = value;
	}
```

### 在index位后插入value
```java
	public void insert(int value, int index) {
		int[] newArr = new int[arr.length+1];
		for(int i=arr.length; i>index+1; i--) {
			newArr[i] = arr[i-1];
		}
		for(int i=0; i<index+1; i++) {
			newArr[i] = arr[i];
		}
		newArr[index+1] = value;
		arr = newArr;
	}
```

### 删除第index位元素
```java
	public void delete(int index) {
		int[] newArr = new int[arr.length-1];
		for(int i=0; i<index; i++) {
			newArr[i] = arr[i];
		}
		for(int i=index; i<newArr.length; i++) {
			newArr[i] = arr[i+1];
		}
		arr = newArr;
	}
```

### 查找值为value的所有的index
```java
	public void search(int value) {
		int[] indexArr = new int[arr.length];
		int count = 0;
		for(int i=0; i<arr.length; i++) {
			if(arr[i] == value) {
				indexArr[count++] = i;
			}
		}
		if(count == 0) {
			System.out.println("It does not found.");
		}else {
			for(int i=0; i<count; i++) {
				System.out.print(indexArr[i] + " ");
			}
		}
	}
```
	
### 二分法查找值为value的元素index，前提是数组是有序的
```java
	public void binarySearch(int value) {
		
		int start = 0;
		int end = arr.length-1;
		int mid = (start + end) / 2;
		while(true) {
			if(arr[mid] == value) {
				System.out.println(mid);
				break;
			}else {
				if(arr[mid] > value) {
					end = mid-1;
				}else {
					start = mid+1;
				}
				mid = (start + end) / 2;
			}
		}
	}
}
```

### 测试用例
```java 
public class TestMyArray {
	public static void main(String args[]) {
		MyArray arr = new MyArray();
		
		arr.add(1);
		arr.add(2);
		arr.show();
		//arr: [1, 2]

		
		arr.replace(1, 1);
		arr.show();
                //arr: [1, 1]

		
		arr.insert(3, 0);
		arr.show();
		//arr: [1, 3, 1]

		
		arr.delete(1);
		arr.show();
		//arr: [1, 1]

		
		arr.search(2);
		//It does not found.

		
		MyArray orderArr = new MyArray();
		
		orderArr.add(1);
		orderArr.add(2);
		orderArr.add(3);
		
		orderArr.binarySearch(2);
		//1
		
		
	}
}

```


## 栈
### 建立新栈及输出展示
```java
public class MyStack {
	public int[] stack;
	
	public MyStack() {
		stack = new int[0];
	}
	
	public void show() {
		System.out.println(Arrays.toString(stack));
	}
```

### 入栈
```java
    public void push(int value) {
		int[] newStack = new int[stack.length+1];
		for(int i=0; i<stack.length; i++) {
			newStack[i] = stack[i];
		}
		newStack[stack.length] = value;
		stack = newStack;
	}
``` 

### 出栈
```java
    public void pop() {
		int[] newStack = new int[stack.length-1];
		for(int i=0; i<newStack.length; i++) {
			newStack[i] = stack[i];
		}
		stack = newStack;
	}
```

### 查看栈顶元素及查看是否为空
```java
    public int peek() {
		return stack[stack.length-1];
	}
	
	public Boolean isEmpty() {
		if(stack.length == 0) {
			return true;
		}
		return false;
	}
	
}
```  
### 测试用例
```java
public class TestMyStack {
	public static void main(String args[]) {
		MyStack stack = new MyStack();
		
		stack.push(1);
		stack.push(2);
		stack.push(3);
		stack.show();
		//[1, 2, 3]
		
		stack.pop();
		stack.show();
		//[1, 2]

		
		System.out.println(stack.peek());
		//2
		stack.show();
		//[1, 2]

		
		System.out.println(stack.isEmpty());
		//false
	}
}

```


## 队列
### 建立新队列及输出显示
 ```java
 public class MyQueue {
	public int[] queue;
	
	public MyQueue() {
		queue = new int[0];
	}
	
	public void show() {
		System.out.println(Arrays.toString(queue));
	}
 ```   
 
### 入队
```java
    public void add(int value) {
		int[] newQueue = new int[queue.length+1];
		for(int i=0; i<queue.length; i++) {
			newQueue[i] = queue[i];
		}
		newQueue[queue.length] = value;
		queue = newQueue;
	}
```

### 出队
```java
    public void poll() {
		int[] newQueue = new int[queue.length-1];
		for(int i=0; i<newQueue.length; i++) {
			newQueue[i] = queue[i+1];
		}
		queue = newQueue;
	}
```

### 判断队列是否为空
```java
    public Boolean isEmpty() {
		if(queue.length == 0) {
			return true;
		}
		return false;
	}
}
```

### 测试用例
```java
public class TestMyQueue {
	public static void main(String args[]) {
		MyQueue queue = new MyQueue();
		
		queue.add(1);
		queue.add(2);
		queue.add(3);
		queue.show();
		//[1, 2, 3]
		
		queue.poll();
		queue.show();
		//[2, 3]

		System.out.println(queue.isEmpty());
		//false

	}
}
```

 

## 单链表
### 建立单链表及输出展示
```java
public class Node {
	int data;
	Node next;
	
	public Node(int data) {
		this.data = data;
	}
	
	public void show() {
		Node curNode = this;
		while(curNode.next != null) {
			System.out.print(curNode.data + " ");
			curNode = curNode.next;
		}
		System.out.println(curNode.data);
	}
```

### 单链表最后加入一个节点
```java
    public void append(Node node) {
		Node curNode = this;
		while(curNode.next != null) {
			curNode = curNode.next;
		}
		curNode.next = node;
		
	}
```

### 判断当前节点是否为单链表最后一个节点
```java
    public Boolean isLast() {
		if(this.next == null) {
			return true;
		}
		return false;
	}
```

### 删除当前节点的下一个节点
```java
    public void removeNext() {
		this.next = this.next.next;
	}
```

### 当前节点后插入一个节点
```java
    public void insertNode(Node node) {
		Node nextNode = this.next;
		this.next = node;
		node.next = nextNode;
	}
```

### 得到当前节点的值
 ```java
    public void getData() {
		System.out.println(this.data);
	}
 ```
 

### 测试用例
```java
public class TestNode {
	public static void main(String args[]) {
		Node n1 = new Node(1);
		Node n2 = new Node(2);
		Node n3 = new Node(3);
		Node n4 = new Node(4);
		Node n5 = new Node(5);
		
		n1.append(n2);
		n1.append(n3);
		n3.append(n4);
		n4.append(n5);
		n1.show();
		//1 2 3 4 5
		
		n1.getData();
		//1
		
		System.out.println(n5.isLast());
		//true
		System.out.println(n3.isLast());
		//false
		
		n1.removeNext();
		n1.show();
		//1 3 4 5
		
		n1.insertNode(n2);
		n1.show();
		//1 2 3 4 5

	}
}
```

## 双链表
### 双链表节点定义及添加节点
```java
    int data;
	DoubleNode next = this;
	DoubleNode pre = this;
	
	public DoubleNode(int data) {
		this.data = data;
	}
	
	public void insert(DoubleNode node) {
		DoubleNode nextNode = this.next;
		this.next = node;
		node.next = nextNode;
		node.pre = this;
		nextNode.pre = this.next;
	}
```

## 单向循环链表
* 没有pre；
* 最后一个节点的next是第一个节点；

## 双向循环链表
* 有pre，有next；
* 第一个节点的pre是最后一个节点；
* 最后一个节点的next是第一个节点；


